package ReseqTrack::Tools::RunVariantCall::RunApplyRecalibration;

use strict;
use warnings;

use ReseqTrack::Tools::Exception qw(throw);
use ReseqTrack::Tools::Argument qw(rearrange);
use ReseqTrack::Tools::FileSystemUtils qw( check_file_exists check_executable);

use base qw(ReseqTrack::Tools::GATKTools);

=head2 new

  Arg [-tranchesFile]   :
      string, path to tranchesFile generated by VariantRecalibrator
  Arg [-recalFile]   :
      string, path to recalFile generated by VariantRecalibrator          
  Arg [-parameters_AR]   :
      string, parameters to pass to the RunApplyRecalibration object; if multiple parameters, use this tag multiple times
      
  + Arguments for ReseqTrack::Tools::RunProgram parent class

  Please see GATK ApplyRecalibration website for detailed descriptions about inputs:
  http://www.broadinstitute.org/gsa/gatkdocs/release/org_broadinstitute_sting_gatk_walkers_variantrecalibration_ApplyRecalibration.html

  Function  : Creates a new ReseqTrack::Tools::RunVariantCall::RunApplyRecalibration object.
  Returntype: ReseqTrack::Tools::RunVariantCall::RunApplyRecalibration
  Exceptions: 
  Example   : my $object_AR = ReseqTrack::Tools::RunVariantCall::RunApplyRecalibration->new(
                            -program                    => path to program executable,
                            -reference                     => path to sequence reference,
                            -input_files                => path_to_input_vcf_file to be recalibrated,
                            -working_dir                => path_to_output_dir,
                            -save_files_from_deletion    => $input{save_files_from_deletion},
                            -tranchesFile                => path_to_tranchesFile,
                            -recalFile                    => path_to_recalFile,
                            -parameters_AR                => {parameter_name=parameter_vale, parameter_name2=parameter_value2},
);

=cut


sub new {

  my ( $class, @args ) = @_;    
  my $self = $class->SUPER::new(@args);

  my ( $reference, $tranches_file, $recal_file, $input_vcf)
        = rearrange( [ qw( REFERENCE TRANCHES_FILE RECAL_FILE INPUT_VCF ) ], @args);

  $self->reference($reference);
  $self->tranches_file($tranches_file);
  $self->recal_file($recal_file);
  $self->input_vcf($input_vcf);
  
  return $self;
}

sub DEFAULT_OPTIONS { return {
        'mode' => 'SNP',
        'ts_filter_level' => '99.0',
        };
}


sub run_program {
    my ($self) = @_; 

    my $input_vcf = $self->input_vcf || throw('no vcf file');
    my $recal_file = $self->recal_file || throw('no recal file');
    my $tranches_file = $self->tranches_file || throw('no tranches file');

    check_file_exists($input_vcf);
    check_file_exists($input_vcf . '.tbi');
    check_file_exists($recal_file);
    check_file_exists($tranches_file);
    
    $self->check_jar_file_exists;
    check_file_exists($self->reference);
    check_executable($self->java_exe);

    my $output_vcf = $self->working_dir .'/'. $self->job_name . '.recal.vcf.gz';
    $output_vcf =~ s{//}{/}g;

    if (!-f "$recal_file.idx") {
      $self->created_files("$recal_file.idx");
    }

    my @cmd_words = ($self->java_exe, $self->jvm_args, '-jar');
    push(@cmd_words, $self->gatk_path . '/' . $self->jar_file);
    push(@cmd_words, '-T', 'ApplyRecalibration');
    push(@cmd_words, '-R', $self->reference);
    push(@cmd_words, '--input', $input_vcf);
    push(@cmd_words, '--tranches_file', $tranches_file);
    push(@cmd_words, '--recal_file', $recal_file);
    push(@cmd_words, '--out', $output_vcf);

    while (my ($tag, $value) = each %{$self->options}) {
        push(@cmd_words, "-$tag", $value);
    }

    my $cmd = join(' ', @cmd_words);
    $self->output_files($output_vcf);
    $self->execute_command_line ($cmd);

    return;
}    


sub recal_file {
  my ($self, $recal_file) = @_;
  if ($recal_file) {
    $self->{'recal_file'} = $recal_file;
    $self->input_files($recal_file);
  }
  return $self->{'recal_file'} || (grep { /\.recal$/ } @{$self->input_files})[0];
}
sub tranches_file {
  my ($self, $tranches_file) = @_;
  if ($tranches_file) {
    $self->{'tranches_file'} = $tranches_file;
    $self->input_files($tranches_file);
  }
  return $self->{'tranches_files'} || (grep { /\.tranches$/ } @{$self->input_files})[0];
}
sub input_vcf {
  my ($self, $vcf) = @_;
  if ($vcf) {
    $self->{'input_vcf'} = $vcf;
    $self->input_files($vcf);
  }
  return $self->{'input_vcf'} || (grep { /\.vcf(?:\.gz)?$/ } @{$self->input_files})[0];
}



1;

=pod

=head1 Example command line  

 java -Xmx3g -jar /nfs/1000g-work/G1K/work/bin/gatk/dist/GenomeAnalysisTK.jar \
   -T ApplyRecalibration \
   -R /nfs/1000g-work/G1K/work/bin/gatk_resource_bundle/human_g1k_v37.fasta  \
   -input /nfs/1000g-work/G1K/work/zheng/snp_calling/gatk/gatk_all_chr20.vcf.gz  \
   --ts_filter_level 99.0 \
   -tranchesFile /nfs/1000g-work/G1K/work/zheng/snp_calling/vqsr/output.tranches \
   -recalFile /nfs/1000g-work/G1K/work/zheng/snp_calling/vqsr/output.recal \
   -o /nfs/1000g-work/G1K/work/zheng/snp_calling/vqsr/gatk_all_chr20.recalibrated.filtered.vcf
